/**
 * @public
 */
export declare type EventType = string | symbol;
/**
 * @public
 */
export declare type Handler<T = any> = (event?: T) => void;
/**
 * @public
 */
export interface IEmitter {
    on<T = any>(type: EventType, handler: Handler<T>): void;
    once<T = any>(type: EventType, handler: Handler<T>): void;
    off<T = any>(type: EventType, handler: Handler<T>): void;
    emit<T = any>(type: EventType, event?: T): void;
}
declare type OffCallbackHandler = () => void;
declare const once: unique symbol;
declare const evts: unique symbol;
/**
 * The event emitter class.
 *
 * @public
 */
export declare class Emitter implements IEmitter {
    private [evts];
    private [once];
    /**
     * Returns the whole EventType list
     */
    events(): EventType[];
    /**
     * Returns `true` if this emmiter has a listener attached to the `key` event type
     */
    has(key: EventType): boolean;
    /**
     * Adds the `handler` function to listen events of the `type` type.
     *
     * @returns a function to unsubscribe the handler invoking `this.off(type, handler)`
     */
    on<T = any>(type: EventType, handler: Handler<T>): OffCallbackHandler;
    /**
     * Adds a *one-time* `handler` function for the event of the `type` type.
     *
     * @returns a function to unsubscribe the handler invoking `this.off(type, handler)`
     */
    once<T = any>(type: EventType, handler: Handler<T>): OffCallbackHandler;
    /**
     * Removes the specified `handler` from the list of handlers of the event of the `type` type
     */
    off<T = any>(type: EventType, handler: Handler<T>): void;
    /**
     * Calls each of the handlers registered for the event of `type` type, in the
     * order they were registered, passing the supplied argument `e` to each.
     */
    emit<T = any>(type: EventType, e?: T): void;
}
export {};
