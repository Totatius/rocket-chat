{"version":3,"file":"tinykeys.module.js","sources":["../src/tinykeys.ts"],"sourcesContent":["type KeyBindingPress = [string[], string]\n\n/**\n * A map of keybinding strings to event handlers.\n */\nexport interface KeyBindingMap {\n\t[keybinding: string]: (event: KeyboardEvent) => void\n}\n\n/**\n * These are the modifier keys that change the meaning of keybindings.\n *\n * Note: Ignoring \"AltGraph\" because it is covered by the others.\n */\nlet KEYBINDING_MODIFIER_KEYS = [\"Shift\", \"Meta\", \"Alt\", \"Control\"]\n\n/**\n * Keybinding sequences should timeout if individual key presses are more than\n * 1s apart.\n */\nlet TIMEOUT = 1000\n\n/**\n * An alias for creating platform-specific keybinding aliases.\n */\nlet MOD =\n\ttypeof navigator === \"object\" &&\n\t/Mac|iPod|iPhone|iPad/.test(navigator.platform)\n\t\t? \"Meta\"\n\t\t: \"Control\"\n\n/**\n * Parses a \"Key Binding String\" into its parts\n *\n * grammar    = `<sequence>`\n * <sequence> = `<press> <press> <press> ...`\n * <press>    = `<key>` or `<mods>+<key>`\n * <mods>     = `<mod>+<mod>+...`\n */\nfunction parse(str: string): KeyBindingPress[] {\n\treturn str\n\t\t.trim()\n\t\t.split(\" \")\n\t\t.map(press => {\n\t\t\tlet mods = press.split(\"+\")\n\t\t\tlet key = mods.pop() as string\n\t\t\tmods = mods.map(mod => (mod === \"$mod\" ? MOD : mod))\n\t\t\treturn [mods, key]\n\t\t})\n}\n\n/**\n * This tells us if a series of events matches a key binding sequence either\n * partially or exactly.\n */\nfunction match(event: KeyboardEvent, press: KeyBindingPress): boolean {\n\t// prettier-ignore\n\treturn !(\n\t\t// Allow either the `event.key` or the `event.code`\n\t\t// MDN event.key: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n\t\t// MDN event.code: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code\n\t\t(\n\t\t\tpress[1].toUpperCase() !== event.key.toUpperCase() &&\n\t\t\tpress[1] !== event.code\n\t\t) ||\n\n\t\t// Ensure all the modifiers in the keybinding are pressed.\n\t\tpress[0].find(mod => {\n\t\t\treturn !event.getModifierState(mod)\n\t\t}) ||\n\n\t\t// KEYBINDING_MODIFIER_KEYS (Shift/Control/etc) change the meaning of a\n\t\t// keybinding. So if they are pressed but aren't part of the current\n\t\t// keybinding press, then we don't have a match.\n\t\tKEYBINDING_MODIFIER_KEYS.find(mod => {\n\t\t\treturn !press[0].includes(mod) && press[1] !== mod && event.getModifierState(mod)\n\t\t})\n\t)\n}\n\n/**\n * Subscribes to keybindings.\n *\n * Returns an unsubscribe method.\n *\n * @example\n * ```js\n * import keybindings from \"../src/keybindings\"\n *\n * keybindings(window, {\n * \t\"Shift+d\": () => {\n * \t\talert(\"The 'Shift' and 'd' keys were pressed at the same time\")\n * \t},\n * \t\"y e e t\": () => {\n * \t\talert(\"The keys 'y', 'e', 'e', and 't' were pressed in order\")\n * \t},\n * \t\"$mod+d\": () => {\n * \t\talert(\"Either 'Control+d' or 'Meta+d' were pressed\")\n * \t},\n * })\n * ```\n */\nexport default function keybindings(\n\ttarget: Window | HTMLElement,\n\tkeyBindingMap: KeyBindingMap,\n) {\n\tlet keyBindings = Object.keys(keyBindingMap).map(key => {\n\t\treturn [parse(key), keyBindingMap[key]] as const\n\t})\n\n\tlet possibleMatches = new Map<KeyBindingPress[], KeyBindingPress[]>()\n\tlet timer: any = null\n\n\tlet onKeyDown = (event: KeyboardEvent) => {\n\t\t// Ensure and stop any event that isn't a full keyboard event.\n\t\t// Autocomplete option navigation and selection would fire a instanceof Event,\n\t\t// instead of the expected KeyboardEvent\n\t\tif (!(event instanceof KeyboardEvent)) {\n\t\t\treturn\n\t\t}\n\n\t\tkeyBindings.forEach(keyBinding => {\n\t\t\tlet sequence = keyBinding[0]\n\t\t\tlet callback = keyBinding[1]\n\n\t\t\tlet prev = possibleMatches.get(sequence)\n\t\t\tlet remainingExpectedPresses = prev ? prev : sequence\n\t\t\tlet currentExpectedPress = remainingExpectedPresses[0]\n\n\t\t\tlet matches = match(event, currentExpectedPress)\n\n\t\t\tif (!matches) {\n\t\t\t\t// Modifier keydown events shouldn't break sequences\n\t\t\t\t// Note: This works because:\n\t\t\t\t// - non-modifiers will always return false\n\t\t\t\t// - if the current keypress is a modifier then it will return true when we check its state\n\t\t\t\t// MDN: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState\n\t\t\t\tif (!event.getModifierState(event.key)) {\n\t\t\t\t\tpossibleMatches.delete(sequence)\n\t\t\t\t}\n\t\t\t} else if (remainingExpectedPresses.length > 1) {\n\t\t\t\tpossibleMatches.set(sequence, remainingExpectedPresses.slice(1))\n\t\t\t} else {\n\t\t\t\tpossibleMatches.delete(sequence)\n\t\t\t\tcallback(event)\n\t\t\t}\n\t\t})\n\n\t\tclearTimeout(timer)\n\t\ttimer = setTimeout(possibleMatches.clear.bind(possibleMatches), TIMEOUT)\n\t}\n\n\ttarget.addEventListener(\"keydown\", onKeyDown as any)\n\treturn () => {\n\t\ttarget.removeEventListener(\"keydown\", onKeyDown as any)\n\t}\n}\n"],"names":["KEYBINDING_MODIFIER_KEYS","MOD","navigator","test","platform","target","keyBindingMap","keyBindings","Object","keys","map","key","str","trim","split","press","mods","pop","mod","possibleMatches","Map","timer","onKeyDown","event","KeyboardEvent","forEach","keyBinding","sequence","callback","remainingExpectedPresses","get","toUpperCase","code","find","getModifierState","includes","match","length","set","slice","clearTimeout","setTimeout","clear","bind","addEventListener","removeEventListener"],"mappings":"AAcA,IAAIA,EAA2B,CAAC,QAAS,OAAQ,MAAO,WAWpDC,EACkB,iBAAdC,WACP,uBAAuBC,KAAKD,UAAUE,UACnC,OACA,kCA0EHC,EACAC,GAEA,IAAIC,EAAcC,OAAOC,KAAKH,GAAeI,IAAI,SAAAC,GAChD,MAAO,EApEMC,EAoECD,EAnERC,EACLC,OACAC,MAAM,KACNJ,IAAI,SAAAK,GACJ,IAAIC,EAAOD,EAAMD,MAAM,KACnBH,EAAMK,EAAKC,MAEf,MAAO,CADPD,EAAOA,EAAKN,IAAI,SAAAQ,SAAgB,SAARA,EAAiBjB,EAAMiB,IACjCP,MA4DKL,EAAcK,IApEpC,IAAeC,IAuEVO,EAAkB,IAAIC,IACtBC,EAAa,KAEbC,EAAY,SAACC,GAIVA,aAAiBC,gBAIvBjB,EAAYkB,QAAQ,SAAAC,GACnB,IAAIC,EAAWD,EAAW,GACtBE,EAAWF,EAAW,GAGtBG,EADOV,EAAgBW,IAAIH,IACcA,GAvEhD,SAAeJ,EAAsBR,GAEpC,QAKEA,EAAM,GAAGgB,gBAAkBR,EAAMZ,IAAIoB,eACrChB,EAAM,KAAOQ,EAAMS,MAIpBjB,EAAM,GAAGkB,KAAK,SAAAf,GACb,OAAQK,EAAMW,iBAAiBhB,MAMhClB,EAAyBiC,KAAK,SAAAf,GAC7B,OAAQH,EAAM,GAAGoB,SAASjB,IAAQH,EAAM,KAAOG,GAAOK,EAAMW,iBAAiBhB,MAsD/DkB,CAAMb,EAFOM,EAAyB,IAU9CN,EAAMW,iBAAiBX,EAAMZ,MACjCQ,SAAuBQ,GAEdE,EAAyBQ,OAAS,EAC5ClB,EAAgBmB,IAAIX,EAAUE,EAAyBU,MAAM,KAE7DpB,SAAuBQ,GACvBC,EAASL,MAIXiB,aAAanB,GACbA,EAAQoB,WAAWtB,EAAgBuB,MAAMC,KAAKxB,GAjIlC,OAqIb,OADAd,EAAOuC,iBAAiB,UAAWtB,cAElCjB,EAAOwC,oBAAoB,UAAWvB"}